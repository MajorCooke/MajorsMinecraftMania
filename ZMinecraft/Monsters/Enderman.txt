/*
$limit Minecraft/Enderman/Death	0
$limit Minecraft/Enderman/Stare 0
$limit Minecraft/Enderman/Hit 0
$limit Minecraft/Enderman/Idle 0
$limit Minecraft/Enderman/Portal 0
$limit Minecraft/Enderman/Scream 0

- Both -
Body:			0.0		0.0		6.6

- Normal -
Head (Angry): 	0.0		0.0		7.8
Arms:			0.0		~1.0	7.6
Legs:			0.0		~.4		5.8

- Gib -
Head:			0.0		0.0		9.4
Arms:			0.0		~1.0	4.8
Legs:			0.0		~.4		3.0

*/



//
const EndermanTargetDistance = 2048.0;
Class MCEnderman : MinecraftEnemy
{
	const _Radius = 1.2;
	const _Height = 9.4;
	const RealScale = 7.0;
	const RealRadius = RealScale * _Radius;
	const RealHeight = RealScale * _Height;

	const NormalSpeed = 3.0;
	const AngerSpeed = 7.0;
	
	mixin NormalLimbCount;
	private Array<CVector3> LimbVec;
	
	Default
	{
		Health 200;
		Mass 200;
		Scale RealScale;
		Radius RealRadius;
		Height RealHeight;
		Speed NormalSpeed;
		RipLevelMin (int.min + 1);
		MaxStepHeight 64;
		BloodColor "Purple";
		ActiveSound "Minecraft/Enderman/Idle";
		PainSound "Minecraft/Enderman/Hit";
		DeathSound "Minecraft/Enderman/Death";
		
		Tag "Enderman";
		Obituary "%o blinked. Then an Enderman ate %p eyes.";
		
		MaxTargetRange EndermanTargetDistance;
	}
	
	override bool DropItems(Actor src, Actor inf, Name mod)
	{
		if (!Super.DropItems(src, inf, mod))
			return false;
			
		if (!A_DropItem('MCEndermanDrop',-1, 13))
		if (!A_DropItem('MCCreeperWeaponSpawner',-1, 20))
		Event.DropItem(self, 'Backpack', -1, 64);
		
		return true;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		AttackDamagers = false;
		Init(LimbCount);
		Limb[Head] = MCBodyPart(Spawn('MCEndermanHead', pos));
		Limb[Body] = MCBodyPart(Spawn('MCEndermanBody', pos));
		Limb[ArmR] = MCBodyPart(Spawn('MCEndermanArmRight', pos));
		Limb[ArmL] = MCBodyPart(Spawn('MCEndermanArmLeft', pos));
		Limb[LegR] = MCBodyPart(Spawn('MCEndermanLegRight', pos));
		Limb[LegL] = MCBodyPart(Spawn('MCEndermanLegLeft', pos));
		for (int i = 0; i < Limb.Size(); i++)
		{
			let lim = Limb[i];
			if (Lim)
			{
				if (i <= Body)		Lim.Master = self;
				else				Lim.Master = Limb[Body];
				Lim.Owner = self;
				Lim.Scale = Scale;
			}
		}
		/*
		Limb[Head].SetPosOffsets((0.0, 0.0, 7.8));
		Limb[Body].SetPosOffsets((0.0, 0.0, 6.6));
		Limb[ArmR].SetPosOffsets((0.0, 1.0, 7.6));
		Limb[ArmL].SetPosOffsets((0.0,-1.0, 7.6));
		Limb[LegR].SetPosOffsets((0.0, 0.4, 5.8));
		Limb[LegL].SetPosOffsets((0.0,-0.4, 5.8));
		*/
		LimbVec.Clear();
		LimbVec.Reserve(Limb.Size());
		for (int i = 0; i < Limb.Size(); i++)
		{
			let vec = CVector3.Create((0,0,0));
			LimbVec[i] = vec;
		}
		
		LimbVec[Head].v = (0.0,	 0.0, 7.8);
		LimbVec[Body].v = (0.0,  0.0, 6.6);
		LimbVec[ArmR].v = (0.0,  1.0, 7.6);
		LimbVec[ArmL].v = (0.0, -1.0, 7.6);
		LimbVec[LegR].v = (0.0,  0.4, 5.8);
		LimbVec[LegL].v = (0.0, -0.4, 5.8);
		
		
		for (int i = 0; i < Limb.Size(); i++)
			if (Limb[i])	Limb[i].SetPosOffsets(LimbVec[i].v);
		
		
		UpdateLimbs();
	}
	
	override void SetupRelations()
	{
		Super.SetupRelations(true);
		SetClassRelation('PlayerPawn', Rel_Neutral, true);
	}
	
	private bool Angry, WasAngry, StaredAt;
	private int MoveWait, StareTimer, StareCount;
	private Actor StaredBy;
	private Array<Actor> Staring;
		
	void Stared(Actor at)
	{
		if (!Angry)
			Staring.Push(at);
		StaredAt = true;		
	}
	
	private void HandleStares()
	{
		if (Staring.Size() < 1)	return;
		
		if (Angry)
		{
			Staring.Clear();
			return;
		}
		Actor closest = null;
		double distance = EndermanTargetDistance ** 2;
		
		for (int i = 0; i < Staring.Size(); i++)
		{
			if (Staring[i] && Targetable(Staring[i]))
			{
				double dist = Distance3DSquared(Staring[i]);
				if (dist >= distance)	continue;
				
				closest = Staring[i];
				distance = dist;
			}
		}
		Staring.Clear();
		
		if (closest != StaredBy)
		{
			StaredBy = Closest;
			StareCount = 0;
		}
		
		if (Closest)
		{
			StareTimer = 5;
			if (StareCount > 7)
				SetAngry(closest, true, true);
			else StareCount++;
		}
	}
	
	void ClearStare()
	{
		StaredAt = false;
		StareTimer = StareCount = 0;
		StaredBy = null;
	}
	
	bool IsAngry() { return Angry; }
	
	void SetAngry(Actor at, bool snd = false, bool stare = false)
	{
		if (at)
		{
			bool trg = Targetable(Target);
			if (trg && stare)
			{
				if (at == Target)
					MoveWait = 2;
				
				return;
			}
			Angry = Targetable(at);
		}
		else Angry = false;
		
		
		if (Angry)	
		{
			Target = at;
			if (!WasAngry && snd)
				A_StartSound("Minecraft/Enderman/Stare", 9, CHANF_OVERLAP, 1, ATTN_NONE);
			ActiveSound = "Minecraft/Enderman/Scream";
			if (Limb[Head])	Limb[Head].Frame = Fr_B;
			Speed = AngerSpeed;
			SetState(ResolveState("See"));
		}
		else
		{
			A_ClearTarget();
			ClearStare();
			ActiveSound = Default.ActiveSound;
			if (Limb[Head])	Limb[Head].Frame = Fr_A;
			Speed = NormalSpeed;
		}
	}
	
	override void Tick()
	{
		
		if (health < 1 || IsFrozen() || bDESTROYED)
		{
			Super.Tick();
			return;
		}
		
		if (MoveWait > 0)	MoveWait--;
		/*
		if (Angry)
		{
			if (StaredAt)	MoveWait = 2;
		}
		else if (StaredAt)
		{
			HandleStares();
		}
		*/
		StaredAt = false;
			
		
		
		if (!(Scale ~== (0,0)) && !(OverScale ~== 0))
		{
			if (Angry)
			{
				double r = 2.0 / (Scale.Y * OverScale);
				Vector3 jiggle = (FFRandom(-r, r), FFRandom(-r, r), 0);
				
				for (int i = 0; i < Limb.Size(); i++)
				{
					let Lim = Limb[i];
					if (!Lim)	continue;
					
					if (i <= Body)	Lim.SetPosOffsets(LimbVec[i].v + jiggle, false);
					else			Lim.UpdatePosition(Lim.Master, false);				
				}
			}
			else if (WasAngry)
			{
				
				for (int i = 0; i < Limb.Size(); i++)
				{
					let Lim = Limb[i];
					if (!Lim)	continue;
					
					if (i <= Body)	Lim.SetPosOffsets(LimbVec[i].v, false);
					else			Lim.UpdatePosition(Lim.Master, false);
				}
			}
		}
		WasAngry = Angry;
		
		Super.Tick();
	}
	
	override void DamageReact(Actor inf, Actor src, int damage, int dmg, Name mod, int flags, double angle, bool secdmg)
	{
		if (dmg < 1)	return;
		if (!src && !inf || mod == 'Fire' || mod == 'Slime' || mod == 'Drowning')
		{
			ClearRelations(Res_Actors);
			SetAngry(src);
			DoTeleport(0);
			return;
		}
		SetAngry(src);
		// if enemy damage is above the legs (5.4 * Scale.Y), give a chance to teleport
		
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		return (InTeleport && !(flags & DMG_FORCED)) ? 0 : Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (InTeleport)
		{
			if (other is 'PlayerPawn' || other.bISMONSTER || other.bMISSILE)
				return false;
		}
		else if (other is 'MCArrowProjectile')
		{
			if (IFRandom(0,3))	return false;
		}
		return Super.CanCollideWith(other, passive);
	}
	
	private bool InTeleport;
	bool DoTeleport(int response = 0)
	{
		//	let Lines = GetIntersectingLines(self, (1024, 1024));
		int i, j, k, l,
			Enemy_Forward = 1,
			Enemy_Dodge = 2,
			iter = 32,
			half = iter / 2;
		double tile = 32;
		k = IFRandom(-half,half);
		L = IFRandom(-half,half);
		Vector3 Closest = pos;
		double CloseDist = 32767;
		for (i = 0; i < iter; i++)
		{
			k = ((k + i) % iter) - half;
			for (j = 0; j < iter; j++)
			{
				l = ((l + j) % iter) - half;
				
				//pos.z = Level.PointInSector(pos.xy).floorplane.ZatPoint(pos.xy);
				Vector3 off = (pos.x + iter * k, pos.y + iter * l, pos.z);
				Sector s = Level.PointInSector(off.xy);
				
				if (s.DamageAmount > 0 && GetDamageFactor(s.DamageType, s.DamageAmount) > 0)
					continue;
				
				off.z = s.floorplane.ZatPoint(off.xy);
				if (!Level.IsPointInLevel(off) || 
					off.z > pos.z + double(32 * iter) || 
					off.z < pos.z - double(32 * iter))
					continue;
				
				double curz = pos.Z;
				SetZ(off.Z);
				if (CheckPosition(off.XY))
				{
					if (response == Enemy_Forward)
					{
						if (Targetable(Target))
						{
							double dis = Distance3DSquared(target);
							if (dis < CloseDist)
							{
								closest = off;
								CloseDist = dis;
							}
						}
					}
					else
					{
						SetOrigin(off, true);
						A_StartSound("Minecraft/Enderman/Portal", 9, CHANF_OVERLAP);
						return true;
					}
				}
			}
		}
		
		if (response < 1)	return false;
		
		SetOrigin(closest, true);
		A_StartSound("Minecraft/Enderman/Portal", 9, CHANF_OVERLAP);
		return true;
	}
	
	
	
	States
	{
	Spawn:
		TNT1 AA 35;
		Goto IdleMove;
	Idle:
		TNT1 A 0 
		{
			SetAngry(null);
			return A_Jump(256, IRandom(1, 4));
		}
		TNT1 AAAAAAAAAA 17 Look();
	IdleMove:
		TNT1 A 0 
		{
			SetAngry(null);
			LookTimer = 0;
			return A_Jump(256, IRandom(1, 35*2));
		}
		TNT1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		TNT1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		TNT1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		TNT1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		Goto Idle;
	See:
		TNT1 A 1 
		{
			if (!ValidateTarget(true, TargetOnly: true))
			{
				SetAngry(null);
				ClearRelations(Res_Actors);
				return ResolveState('Idle');
			}
			int flag = (MoveWait > 0) ? CHF_DONTMOVE : 0;
			Chase(flags: flag|CHF_NOPLAYACTIVE);
			return ResolveState(null);
		}
		Wait;
	Melee:
		TNT1 A 1 DoMelee(IRandom(20, 25));
		Goto See;
	}
}

Class MCEndermanDrop : RandomSpawner
{
	Default
	{
		DropItem "BlurSphere", 256, 10;
		DropItem "Berserk", 256, 10;
		DropItem "InvulnerabilitySphere", 256, 1;
	}
}

//==============================================================================
//==============================================================================
// Enderman Tracer
//
// This is called whenever an enederman is present, in order to get all players
// information at what they're looking at. In this case, if looking at an
// Enderman's upper boundary box where the head is, provided he's passive,
// trigger the beast.
//==============================================================================
//==============================================================================


extend class MinecraftHandler
{
	transient private EnderTracer etrc;
	private void DoEnderTrace()
	{
		if (!etrc)	etrc = new('EnderTracer');
		
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (!playeringame[i] || !players[i].mo)
				continue;
			
			Actor plr = players[i].mo;
			if (!plr)	continue;
			
			Vector3 ang = MC_Map.AnglesToVector(plr.angle, plr.pitch);
			Vector3 pos = plr.Vec2OffsetZ(0,0,plr.player.viewz);
			
			bool Pushed = false;
			etrc.HitList.Clear();
			etrc.Trace(pos, plr.CurSector, ang, EndermanTargetDistance, 0);
			
			Array<EnderHitList> hl; hl.Move(etrc.HitList);
			MCEnderman mo = null;
			for (int i = 0; i < hl.Size(); i++)
			{
				if (!hl[i])	continue;
				mo = hl[i].mo;
				if (mo && !mo.bKILLED && !mo.CheckFear(plr))
				{
					Vector3 hitpos = etrc.Results.HitPos;
					let head = mo.GetHead();
					if (head && hitpos.z >= head.pos.z)
					{
						mo.SetAngry(plr, true, true);
					//	mo.Stared(plr);
					}
				}
			}
		}
	}
}

Class EnderHitList
{
	MCEnderman mo;
	Vector3 HitPos, HitVector;
}

Class EnderTracer : LineTracer
{
	Array<Actor> Endermen;
	Array<EnderHitList> HitList;
	override ETraceStatus TraceCallback() 
	{
		switch (Results.HitType) 
		{
			case TRACE_HitFloor:
			case TRACE_HitCeiling:
			case TRACE_HitNone:
				return TRACE_Stop;
			case TRACE_HitActor:
			{
				let mo = MCEnderman(Results.HitActor);
				if (mo)
				{
					let et = new('EnderHitList');
					et.mo = mo;
					et.HitPos = Results.HitPos;
					et.HitVector = Results.HitVector;
					HitList.Push(et);
				}
				return TRACE_Skip;
			}
			case TRACE_HitWall:
			{
				if (Results.Tier == TIER_Upper || Results.Tier == TIER_Lower) 
					return TRACE_Stop;

				let hl = Results.HitLine;
				int hf = hl.flags;
				
				if (hf & (Line.ML_BLOCKING | Line.ML_BLOCKEVERYTHING | Line.ML_BLOCKHITSCAN))
					return TRACE_Stop;
				
				if (Results.Tier == TIER_Middle && (hf & Line.ML_BLOCKING) && (hf & Line.ML_TWOSIDED))
					return TRACE_Skip;
				
			}
		}
		return TRACE_Skip;
	}
}

Class MCEndermanArm : MCBodyPartArm
{
	Default
	{
		MCBodyPart.SwingAngleCap 30.0;
		MCBodyPart.Gib 'MCEndermanArmGib';
		MCBodyPart.CurAction (E_Swing|E_Sway);
		Radius 0.2;
		Height 6.0;
	}
}

Class MCEndermanArmRight : MCEndermanArm
{	
	Default	
	{	
		MCBodyPart.SineOffset 180, 180, 180;
		MCBodyPart.VelSineOffset 180;
	}
}

Class MCEndermanArmLeft : MCEndermanArm {}

Class MCEndermanBody : MCBodyPart	{}

Class MCEndermanHead : MCBodyPartHead	{}

Class MCEndermanLeg : MCBodyPartLeg
{
	Default
	{
		MCBodyPart.SwingAngleCap 30.0;
		MCBodyPart.Gib 'MCEndermanLegGib';
		Radius 0.2;
		Height 6.0;
	}
}

Class MCEndermanLegRight : MCEndermanLeg {}

Class MCEndermanLegLeft : MCEndermanLeg
{	
	Default
	{
		MCBodyPart.Gib 'MCEndermanLegGib';
		MCBodyPart.SineOffset 180, 180, 180;
		MCBodyPart.VelSineOffset 180;
	}
}

Class MCEndermanBodyGib : MCBodyPartGib	{}

Class MCEndermanHeadGib : MCBodyPartGib
{	Default {	MCBodyPartGib.Offsets 0, 0, 1.6;	}	}

Class MCEndermanArmGib : MCBodyPartGib
{	Default {	MCBodyPartGib.Offsets 0, 0, -2.8;	}	}

Class MCEndermanLegGib : MCBodyPartGib
{	Default {	MCBodyPartGib.Offsets 0, 0, -2.8;	}	}