//

Class MCZombieSpawner : RandomSpawner
{
	Default
	{
		DropItem "MCZombie",		255, 10;
	//	DropItem "MCHusk",			255, 4;
	//	DropItem "MCDrowned",		255, 1;
	}
}

Class MCSkeletonSpawner : RandomSpawner
{
	Default
	{
		DropItem "MCSkeleton",			255, 10;
	//	DropItem "MCStraySkeleton",		255,  5;
	//	DropItem "MCWitherSkeleton",	255,  1;
	}
}

Class MinecraftHandler : EventHandler
{
	const DespawnTimer = Second * 5;
	const CleanTimer = Second * 10;
	enum ETimers
	{
		S_Spawn = 0,
		S_Clean,
		S_Despawn,
		S_Max
	};
	
	private int MobCount, EndermanCount;
	private double DespawnDist;
	private int Timer[S_Max];
	private MCSpawnList SpawnList;
	private Array<MCMountInfo> MountList;
	
	AArray Monsters;
	
	
	
	
	static MinecraftHandler Fetch()
	{
		return MinecraftHandler(Find("MinecraftHandler"));
	}
	
	
	/*
	override void WorldLineActivated(WorldEvent e)
	{
		Line l = e.ActivatedLine;
		// Floor_*TxTy - changes texture before/after movement and gets the special.
		
		Sector f = l.frontsector;
		Sector b = l.backsector;
		
		Switch(l.special)
		{
			Case 239:
			Case 241:		
			{
				if (l.Args[0] == 0)
				{
					if (f && f.DamageAmount > 0)
						DamageSectors.AddSector(b);
				}
				else
				{
					let it = level.CreateSectorTagIterator(l.Args[0]);
					int id = it.Next();
					while (id > -1)
					{
						DamageSectors.AddSector(level.Sectors[id]);
						id = it.Next();
					}
				}
				break;
			}
			Default:
				break;
		}
	}
	*/
	
	override void OnRegister()
	{
		if (!level || level.LevelName == 'TitleMap')
		{
			Destroy();
			return;
		}
		Super.OnRegister();
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		MountList.Clear();
		Monsters = AArray.Create();
		InitQueues();
		CreateSpawnList();
		Timer[S_Spawn] = Second;
		/*
		DamageSectors = MC_SectorContainer.Create();
		for (int i = 0; i < level.Sectors.Size(); i++)
		{
			Sector s = level.Sectors[i];
			if (s.DamageAmount > 0)
				DamageSectors.AddSector(s);
		}
		*/
		// TO DO: Find out via testing and printing what the line specials are
		// for floorLowerAndChange, etc.
		
	}
	
	override void WorldThingSpawned(WorldEvent e)
	{
		let mo = MinecraftEnemy(e.Thing);
		if (mo)	
		{
			mo.Event = self;
			mo.StartHealth *= Max(0.5, MCC_HealthMul);
			mo.Health *= Max(0.5, MCC_HealthMul);;
			Monsters.Push(mo);
			MobCount++;
			
			if (mo is 'MCEnderman')
				EndermanCount++;
		}
	}
	
	override void WorldThingDied(WorldEvent e)
	{
		let mo = MinecraftEnemy(e.Thing);
		if (mo)	
		{
			MobCount--;
			Monsters.Delete(mo);
			
			if (mo is 'MCEnderman')
				EndermanCount--;
		}
	}
	
	override void WorldThingDestroyed(WorldEvent e)
	{
		let mo = MinecraftEnemy(e.Thing);
		if (mo && !mo.bKILLED) 
		{
			MobCount--;
			if (mo is 'MCEnderman')
				EndermanCount--;
		}
	}
	
	override void WorldThingDamaged(WorldEvent e)
	{
		let src = MinecraftEnemy(e.DamageSource);
		if (src)
		{
			let mo = e.Thing;
			if (mo && mo is 'PlayerPawn' && !mo.FindInventory("MCImmunityFrames"))
			{
				mo.A_GiveInventory('MCImmunityFrames',1);
				if (!(mo is 'MinecraftEnemy'))
					mo.A_StartSound("Minecraft/Hit", 9, CHANF_OVERLAP);
			}
		}
	}
	
	void DropItem(Actor mo, Class<Inventory> Cls, int Amount = -1, int Chance = 256)
	{
		if (!mo || !Cls)	return;
		
		Inventory Item = Inventory(mo.A_DropItem(Cls, Amount, Chance));
		if (Item && !Item.bBIGPOWERUP && !(Item is 'Ammo') && !(Item is 'Weapon'))
		{
			let DropTimer = MCDropTimer.Create(Item);
		}
	}
	
	
	override void WorldTick()
	{
		if (level.LevelName == 'TitleMap' || level.MapName == 'TitleMap')
			return;
		if (MobCount > 0 && ++Timer[S_Despawn] >= DespawnTimer)
		{
			Timer[S_Despawn] = 0;
			for (int i = 0; i < Monsters.Size(); i++)
			{
				let mo = Monsters.Actors[i];
				if (!mo)	continue;
				
				if (mo.A_CheckRange(4096, "Null", true) ||
					(mo.A_CheckRange(2048, "Null", true) && random[rng](1,256) <= 32))
				{
					mo.Destroy();
				}
			}
		}
		
		DoEnderTrace();
		
		if (++Timer[S_Clean] >= CleanTimer)
		{
			Timer[S_Clean] = 0;
			Monsters.Clean();
			SpawnQueue.Clean();
			SpawnQueuePriority.Clean();
			ClsQueue.Clean();
			ClsQueuePriority.Clean();
			
			MobCount = 0;
			EndermanCount = 0;
			for (int i = 0; i < Monsters.Size(); i++)
			{
				let mo = MinecraftEnemy(Monsters.Actors[i]);
				if (mo && mo.health > 0)
				{
					mo.CleanActors();
					mo.CleanDamagers();
					MobCount++;
					if (mo is 'MCEnderman')
						EndermanCount++;
				}
			}
		}
		
		// Spawn monsters spherically around players.
		HandleMapSpawns();
	}
}

