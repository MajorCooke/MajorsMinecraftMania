//

Class MCZombieSpawner : RandomSpawner
{
	Default
	{
		DropItem "MCZombie",		255, 10;
	//	DropItem "MCHusk",			255, 4;
	//	DropItem "MCDrowned",		255, 1;
	}
}

Class MCSkeletonSpawner : RandomSpawner
{
	Default
	{
		DropItem "MCSkeleton",			255, 10;
	//	DropItem "MCStraySkeleton",		255,  5;
	//	DropItem "MCWitherSkeleton",	255,  1;
	}
}

//==============================================================================
// Minecraft Event Handler
//==============================================================================

Class MinecraftHandler : EventHandler
{
	mixin TM_FastRNG;
	const DespawnTimer = Second * 5;
	const CleanTimer = Second * 10;
	enum ETimers
	{
		S_Spawn = 0,
		S_Clean,
		S_Despawn,
		S_Max
	};
	
	private Array<Int> BannedSectors;
	private int MobCount, EndermanCount;
	private double DespawnDist;
	private int Timer[S_Max];
	private Array<MCMountInfo> MountList;
	AArray SmokeCount;
	AArray Monsters;
	private Array<SkyViewpoint> skies;
	
	override void NetworkProcess(ConsoleEvent e)
	{
		int num = e.Player;
		let plr = players[num].mo;
		
		if (e.Name == 'TM_TogglePeaceful')
		{
			Cvar p = Cvar.GetCvar("MCC_Peaceful");
			bool res = p.GetBool();
			if (p)	p.SetBool(!res);
			
			if (!res)			Console.Printf("Peaceful Mode On");
			else				Console.Printf("Peaceful Mode Off");
			return;
		}
		
		if (e.Name == 'TM_ToggleSpawning')
		{
			Cvar p = Cvar.GetCvar("MCC_Spawning");
			bool res = p.GetBool();
			if (p)	p.SetBool(!res);
			
			if (!res)			Console.Printf("Spawning On");
			else				Console.Printf("Spawning Off");
			return;
		}
		
		if (e.Name == 'TM_Launch')
		{
			let it = ThinkerIterator.Create('MinecraftMonster', Thinker.STAT_DEFAULT);
			MinecraftMonster mo;
			while (mo = MinecraftMonster(it.Next()))
			{
				if (mo && !mo.bDORMANT && !mo.bNOGRAVITY && mo.Gravity > 0.0 && !mo.bKILLED)
					if (mo.vel.z < 100.0)
						mo.vel.z = 100.0;
			}
		}
	}
	
	static MinecraftHandler Fetch()
	{
		return MinecraftHandler(Find("MinecraftHandler"));
	}
	
	override void OnRegister()
	{
		if (!level || level.LevelName == 'TitleMap')
		{
			Destroy();
			return;
		}
		Super.OnRegister();
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		BannedSectors.Clear();
		MountList.Clear();
		Monsters = AArray.Create();
		CreateSpawnList();
		Timer[S_Spawn] = Second;
		MCC_AIDifficulty_Prev = MCC_AIDifficulty;
	}
	
	override void WorldThingSpawned(WorldEvent e)
	{
		if (!e.Thing || e.Thing.bDESTROYED || e.Thing.bNOINTERACTION)
			return;
			
		let mo = MinecraftMonster(e.Thing);
		if (mo)	
		{
			mo.Event = self;
			Monsters.Push(mo);
			MobCount++;
			
			if (mo is 'MCEnderman')
				EndermanCount++;
			return;
		}
		
		let sk = SkyViewpoint(e.Thing);
		if (sk)	
		{
			BanConnectedSectors(sk.CurSector);
			return;
		}
		
	}
	
	// 1. Get the sector right off the bat where the SkyViewpoint is and ban it.
	// 2. Iterate through all lines that have a front or back sector connecting
	// to it, and ban them too.
	
	private bool BanSector(Sector s)
	{
		if (!s || IsSectorBanned(s.Index()))
			return false;
			
		BannedSectors.Push(s.Index());
		return true;
	}
	
	private bool IsSectorBanned(int index)
	{
		return (index < 1 || BannedSectors.Find(index) < BannedSectors.Size());
	}
	
	private void BanConnectedSectors(Sector s)
	{
		if (!s || IsSectorBanned(s.Index()))	return;
		
		Array<Int> Process; 
		Process.Clear();
		Process.Push(s.Index());
		
		int Failsafe = 2000;
		while (Process.Size() > 0 && --Failsafe > 0)
		{
			// Get the last sector index for processing and remove it from the list.
			int ind = Process.Size() - 1;
			int id = Process[ind];
			Process.Pop();
			
			// Now ban the sector. The ban will fail if it's already banned or
			// the index is invalid, so skip it.
			
			Sector sec = level.Sectors[id];
			if (!BanSector(sec))
				continue;
			
			// If the ban succeeds, go through all its lines and add the indexes
			// to the list of sectors to be banned if they aren't already.
			for (int i = 0; i < sec.lines.Size(); i++)
			{
				int index[2] = {0,0};
				Line l = sec.lines[i];
				
				if (!l)	continue;
				
				if (l.frontsector)		index[0] = l.frontsector.Index();
				if (l.backsector)		index[1] = l.backsector.Index();
					
				for (int j = 0; j < 2; j++)
				{
					if (!IsSectorBanned(index[j]) && 
						Process.Find(index[j]) >= Process.Size())
						Process.Push(index[j]);
				} 
			}
		}
		
		if (Failsafe < 1)
			Console.Printf("WARNING! Sector iteration broke the failsafe!");
	}
	
	override void WorldThingDied(WorldEvent e)
	{
		let mo = MinecraftMonster(e.Thing);
		if (mo)	
		{
			MobCount--;
			Monsters.Delete(mo);
			
			if (mo is 'MCEnderman')
				EndermanCount--;
		}
	}
	
	override void WorldThingDestroyed(WorldEvent e)
	{
		let mo = MinecraftMonster(e.Thing);
		if (mo && !mo.bKILLED) 
		{
			MobCount--;
			if (mo is 'MCEnderman')
				EndermanCount--;
		}
	}
	/*
	override void WorldThingDamaged(WorldEvent e)
	{
		let src = MinecraftMonster(e.DamageSource);
		if (src)
		{
			let mo = e.Thing;
			if (mo && mo is 'PlayerPawn' && !mo.FindInventory("MCImmunityFrames"))
			{
				mo.A_GiveInventory('MCImmunityFrames',1);
				if (!(mo is 'MinecraftMonster'))
					mo.A_StartSound("Minecraft/Hit", 9, CHANF_OVERLAP);
			}
		}
	}
	*/
	
	private void HandleRandomSpawners(out Class<Actor> Cls)
	{
		if (!(Cls is 'RandomSpawner'))
			return;
		
		int RecursionCount = RandomSpawner.MAX_RANDOMSPAWNERS_RECURSION;
		while (Cls is 'RandomSpawner' && RecursionCount > 0)
		{
			let def = GetDefaultByType(Cls);
			if (def)
			{
				DropItem n = def.GetDropItems();
			}
		}
	}
	
	bool DropItem(Actor mo, Class<Actor> Cls, int Amount = -1, int Chance = 256)
	{
		if (!mo || !Cls || Chance < 1 || Amount == 0)	return false;
		
		Array<Actor> drops;	drops.Clear();
		bool good = false;
		if (MCC_CombineItems || Amount < 1)
		{
			Actor check = null;
			check = mo.A_DropItem(Cls, -1, Chance);
			if (!check)
				return false;
			if (check is 'RandomSpawner')
				return true;
			if (check is 'Inventory')
				drops.Push(check);
		}
		else
		{
			for (int i = 0; i < Amount; i++)
			{
				Actor check = mo.A_DropItem(Cls, -1, Chance);
				if (!check)	continue;
				else if (check is 'RandomSpawner')
				{
					good = true;
					continue;
				}
				else if (check && check is 'Inventory')
				{
					drops.Push(check);
				}
			}
		}
		
		if (drops.Size() < 1)	return good;
		
		for (int i = 0; i < drops.Size(); i++)
		{
			Inventory Item = Inventory(drops[i]);
			if (Item && !Item.bBIGPOWERUP && !(Item is 'Weapon'))
			{
				let DropTimer = MCDropTimer.Create(Item);
				if (MCC_CombineItems && Amount > 0)
					Item.Amount *= Amount;
			}
		}
		return true;
	}
	
	private int MCC_AIDifficulty_Prev;
	override void WorldTick()
	{
		if (level.LevelName == 'TitleMap' || level.MapName == 'TitleMap' || level.IsFrozen())
			return;
		
		if (MobCount > 0 && ++Timer[S_Despawn] >= DespawnTimer)
		{
			Timer[S_Despawn] = 0;
			for (int i = 0; i < Monsters.Size(); i++)
			{
				let mo = MinecraftMonster(Monsters.Actors[i]);
				if (!mo || (mo.Target && mo.Targetable(mo.Target)))	continue;
				
				double  dmin = mo.DespawnRangeMin,
						dmax = mo.DespawnRangeMax;
				
				if (mo.A_CheckRange(mo.DespawnRangeMin, "Null", true))
				{
					
					double closest = dmax ** 2;
					for (int i = 0; i < MAXPLAYERS; i++)
					{
						if (!playeringame[i])	continue;
						let plr = players[i].mo;	
						if (!plr || plr.bKILLED)	continue;
						
						closest = min(mo.Distance2DSquared(plr), closest);
					}
					
					if (closest < dmin)
						continue;
					else if (closest >= dmax)
						mo.Destroy();
					else
					{
						double scalar = MC_Functions.GetFalloff(dmin, dmax, closest);
						int chance = int(round(1000.0 * scalar));
						if (irandom(1, 1000) <= chance)
							mo.Destroy();
					}
				}
			}
		}
		
		// If there's enderman around, check player LOS and trigger them if
		// staring at their heads.
		if (EndermanCount > 0)
			DoEnderTrace();
		
		if (++Timer[S_Clean] >= CleanTimer)
		{
			Timer[S_Clean] = 0;
			Monsters.Clean();
			/*
			SpawnQueue.Clean();
			SpawnQueuePriority.Clean();
			ClsQueue.Clean();
			ClsQueuePriority.Clean();
			*/
			MobCount = 0;
			EndermanCount = 0;
			for (int i = 0; i < Monsters.Size(); i++)
			{
				let mo = MinecraftMonster(Monsters.Actors[i]);
				if (mo && !mo.bKILLED)
				{
					mo.CleanActors();
					mo.CleanDamagers();
					MobCount++;
					if (mo is 'MCEnderman')
						EndermanCount++;
				}
			}
		}
		
		// Spawn monsters spherically around players.
		HandleMapSpawns();
	}
	
	
}

