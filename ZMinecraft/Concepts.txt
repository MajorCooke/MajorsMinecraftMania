class NextDamageTic
{
	private Array<Int> Damage;
	private Array<CVector3> Vel;
	private Array<Actor> inf, src;
	private Array<Name> mod;
	
	int i;
	int size;
	bool Collecting;
	
	static NextDamageTic Create();
	{
		let ndt = new('NextDamageTic');
		ndt.Clear();
		return ndt;
	}
	
	protected void Init()
	{
		i = size = 0;
		Clear();
	}
	
	void Clear()
	{
		Damage.Clear();
		Vel.Clear();
		inf.Clear();
		src.Clear();
		mod.Clear();
	}
	
	void Reset()
	{
		i = 0;
	}
	
	bool Next()
	{
		if (i >= size)	return false;
		else
		{
			i++;
			return true;
		}
	}
}

//==============================================================================

// ReplaceInfoManager
//
// Replacement handling storage area used to house information about who replaces
// what, their category, and tiers.

Class CPReplaceInfo
{
	// Replacement,				Replacee
	private Dictionary Replacement;	
	// Replacement,				<category flags>
	private Dictionary Category;
	// Replacement,				<# int>
	private Dictionary Tiers[MaxTiersInit];
	
	
	// Creates the info manager.
	static CPReplaceInfo Create()
	{
		let rep = new('CPReplaceInfo');
		if (rep)	rep.Init();
		return rep;
	}
	
	// Initializes the included dictionaries.
	protected void Init()
	{
		Replacement = Dictionary.Create();
		Category = Dictionary.Create();
		for (int i = 0; i < MaxTiers; i++)
			Tiers[i] = Dictionary.Create();
	}
	
	// Make sure the actors are valid.
	private bool ValidateActor(String Repment, String Repee)
	{
		Class<Actor> mon = Repee;
		Class<Actor> rep = Repment;
		if (!mon || !rep)
		{
			if (!mon && !rep)
				Console.Printf("%s & %s - bad actor(s)", Repee, Repment);
			else if (!mon)
				Console.Printf("%s | %s - bad replaceE", Repee, Repment);
			else
				Console.Printf("%s | %s - bad replaceMENT", Repee, Repment);
			
			return false;
		}
		return true;
	}
	
	// Adds a tiered actor, whether it's a monster, weapon, ammo, powerup or whatever.
	void AddTieredActor(String Repee, String Repment, int weight, int type, 
		int t1, int t2, int t3,	int t4, int t5, int t6, int t7, int t8)
	{	
		// If someone needs to add a weightless actor, use AddActor.
		if (weight + t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 < 1)
		{
			Console.Printf("%s - No spawn weight, skipping", Repment);
			return;
		}
		
		if (!AddActor(Repment, Repee))	return;
		
		Category.Insert(Repment, Max(type, CPT_REGULAR));
		Tiers[0].Insert(Repment, Max(0, weight));
		Tiers[1].Insert(Repment, Max(0, t1));
		Tiers[2].Insert(Repment, Max(0, t2));
		Tiers[3].Insert(Repment, Max(0, t3));
		Tiers[4].Insert(Repment, Max(0, t4));
		Tiers[5].Insert(Repment, Max(0, t5));
		Tiers[6].Insert(Repment, Max(0, t6));
		Tiers[7].Insert(Repment, Max(0, t7));
		Tiers[8].Insert(Repment, Max(0, t8));
	}
	
	bool AddActor(String Repment, String Repee)
	{
		if (!ValidateActor(Repment, Repee))	return false;
		
		// Force lower case to avoid case sensitivity mismatch.
		Repee = Repee.MakeLower();
		Repment = Repment.MakeLower();
		
		// No need to check for pre-existence since it will simply override it.
		Replacement.Insert(Repment, Repee);
		return true;
	}
	
	
	//==========================================================================
	// Getter Functions
	//==========================================================================
	
	//--------------------------------------------------------------------------
	// Get the weight of the tier if it exists. Returns -1 if it doesn't have any.
	CPTiers GetWeights(String Repment, int tier = 0)
	{
		if (tier < 0 || tier > MaxTiers)	
			return -1;
		
		
		String check = Tiers[tier].At(Repment);
		if (check.Length() < 1)	
			return -1;
		
		return Max(0,check.ToInt());
	}
	
	
	//--------------------------------------------------------------------------
	// Checks if a value exists and modifies the array of keys. Dynamic arrays
	// are passed by reference so modifying them will affect the variable where
	// it comes from.
	bool GetKeys(Dictionary d, String Val, Array<String> Keys)
	{
		if (!d || Val == '' || Val == 'None')	return false;
		
		DictionaryIterator i = DictionaryIterator.Create(d);
		bool good = false;
		Keys.Clear();
		while (i.Next())
		{
			if (i.Value() ~== Val) 
			{
				good = true;
				Keys.Push(i.Key());
			}
		}
		return good;
	}
}

//------------------------------------------------------------------------------
// A failed attempt at making a line finder.
//------------------------------------------------------------------------------

let LC = MC_Map.GetIntersectingLines(self, (2048, 2048));
			
			if (!LC)	return;
		//	Console.Printf("Lines made.");
		//	LC.SortDeltas();
			
			for (int i = 0; i < LC.Lines.Size(); i++)
			{
				Line l = LC.Lines[i].lin;
				// Make sure there's a sector in front and behind.
				if (!l)
				{
				//	Console.Printf("%d: No line. Skipping.", i);
					continue;
				}
				
				if ((l.flags & (Line.ML_BLOCKING|Line.ML_BLOCKMONSTERS)))
				{
				//	Console.Printf("%d: Blocking line. Skipping.", i);
					continue;
				}
				
				// No walls.
				if (!l.frontsector || !l.backsector)
				{
				//	Console.Printf("%d: Missing front or back sector. Skipping.", i);
					continue;
				}
				
				let f = l.frontsector;
				let b = l.backsector;
				
				if (f.DamageAmount > 0 && b.DamageAmount > 0)
				{
				//	Console.Printf("%d: Both sectors damaging. Skipping.", i);
					continue;
				}
				
				bool front = true;
				Sector s = b;
				if (f.DamageAmount < 1)
				{
					s = f;
					front = false;
				}
				
			
				Vector2 cpos = level.vec2offset(l.v1.p, l.v2.p) / 2.0;
				Vector2 offadd = cpos;// + Vec2Angle(1, VectorAngle(cpos.x, cpos.y) + (front ? 0 : 180));
			
				
			//	Console.Printf("%d %d -- %d %d", l.delta.x, l.delta.y, cpos.x, cpos.y);
				FCheckPosition tm;
				tm.thing = self;
				tm.pos = pos;
				
				bool thruactors = bTHRUACTORS;
				bTHRUACTORS = true;
				if (CheckPosition(offadd, false, tm))
				{
					//Console.Printf("1");
					SetGoal((offadd.x, offadd.y, tm.floorz));
					bTHRUACTORS = false;
					return;
				}
				else
				{
				//	Console.Printf("Attempt failed.");
					if (tm.CurSector != CurSector)
					{
						double tempstep = MaxStepHeight;
						if (tm.floorz > pos.z + MaxStepHeight && 
							(abs(pos.z - tm.floorz) > MaxStepHeight && 
							abs(pos.z - s.CenterFloor()) <= MaxStepHeight))
							
						{
							double tempstep = MaxStepHeight;
							MaxStepHeight += abs(tm.floorz - s.CenterFloor());
							bool good = (CheckPosition(offadd, false, tm));
							MaxStepHeight = tempstep;
							bTHRUACTORS = false;
							if (good)
							{
							//	Console.Printf("2");
								SetGoal((offadd.x, offadd.y, tm.floorz));
								return;
							}
							//else Console.Printf("-1");
						}
						//else Console.Printf("-4");						
						if (tm.floorz < pos.z - MaxDropoffHeight &&
							(abs(pos.z - tm.floorz) > MaxDropoffHeight && 
							abs(pos.z - s.CenterFloor()) <= MaxDropoffHeight))
						{
							double tempdrop = MaxDropoffHeight;
							MaxDropoffHeight += tm.floorz - s.CenterFloor();
							bTHRUACTORS = true;
							bool good = (CheckPosition(offadd, false, tm));
							bTHRUACTORS = false;
							MaxDropoffHeight = tempdrop;
							if (good)
							{
							//	Console.Printf("3");
								SetGoal((offadd.x, offadd.y, tm.floorz));
								return;
							}
							//else Console.Printf("-2");
						}
						//else Console.Printf("-5");
					}
				}
			}