/*
Minecraft Enemy
By Major Cooke

The idea behind minecraft enemies is to replicate everything from Minecraft if
possible. This means creeper explosions, spider climbing, skeletons using weapons
and a few other cool tricks.
*/

Class MinecraftEnemy : MinecraftEntity
{
	enum EMobTypes
	{
		M_Normal = 0,
		M_Undead,
		M_Anthropod,
	};
	const AttackDelayMax = 35;
	const DefaultDrownTimer = 35 * 30;
	
	MinecraftHandler Event;
	
	bool OnGround;
	private Vector3 PrevVel;
	private int SectorDamageTimer, LastDamage, AccumulatedDamage,
				DrownTimer, DrownTimerStart, DrownDamage,
				CurrentTranslation, ActiveSoundDelay, DamageTimer;
	
	protected MC_QuatTurner Turner;
	Array<MCBodyPart> Limb;
	protected Vector2 PrevScale;
	protected Vector3 PrevAngs, PrevPos, AngVel, HoldAngs;
	Vector3 Angs;
	protected uint PrevTrans;
	protected double PrevAlpha;
	protected int CurStyle, PrevStyle;
	protected int AttackDelay;
	protected int SoundDelay;
	protected bool Passive, Neutral;
	protected int IdleTimer, ChaseCheckTimer, LookTimer;
	
	double FallDmgVel, VelLen, MaxChaseRange;
	
	meta bool PeacefulDespawn;
	meta int MobType;
	Sound StepSound;
	
	Property FallDmgVel:	FallDmgVel;
	Property StepSound: StepSound;
	Property DrownTimer: DrownTimerStart;
	Property PeacefulDespawn: PeacefulDespawn;
	Property MobType: MobType;
	Property Passive: Passive;
	Property MaxChaseRange: MaxChaseRange;
	
	Default
	{
		MineCraftEnemy.FallDmgVel 15.0;
		MinecraftEnemy.DrownTimer DefaultDrownTimer;
		MinecraftEnemy.PeacefulDespawn true;
		MinecraftEnemy.MobType M_Normal;
		Monster;
		Health 200;
		Speed 4;
		Scale 6;
		PushFactor 0.3;
		PainChance 0; // Handled internally.
		MaxDropoffHeight 64;
		+NEVERRESPAWN
		+NEVERFAST
		-COUNTKILL
		// Preventing bad behaviors that will screw with the monsters.
		+DONTMORPH
		+NOICEDEATH
		+PUSHABLE
		+NOTRIGGER // They wander around, so don't allow them to trigger anything.
		+QUICKTORETALIATE
		+DONTGIB
		+DONTCORPSE
		+ALWAYSTELEFRAG
		+NOTELESTOMP
		+NOKILLSCRIPTS
		
		DamageFactor "Crush", 20.0;
	}
	
	//==========================================================================
	// Base overrides
	//==========================================================================
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		PrevScale = Scale;
		PrevAngs = (Angle, Pitch, Roll);
		PrevPos = Pos;
		PrevTrans = Translation;
		PrevAlpha = Alpha;
		PrevStyle = GetRenderStyle();
		PrevVel = Vel;
		DrownTimer = DrownTimerStart;
		FallDmgVel = -abs(FallDmgVel);
		MaxChaseRange = Max(MaxChaseRange, MaxTargetRange);
		Damager.Clear();
		DmgInfo.Used = true;
	}
	
	override void Activate(Actor activator)
	{
		if (health < 1 || bDESTROYED)	return;
		for (int i = 0; i < Limb.Size(); i++)
			if (Limb[i])	Limb[i].Activate(activator);
		
		UpdateLimbs();
		A_SetShootable();
		A_ChangeLinkFlags(0);
		Super.Activate(activator);
	}
	
	override void Deactivate(Actor activator)
	{
		if (health < 1 || bDESTROYED)	return;
		for (int i = 0; i < Limb.Size(); i++)
			if (Limb[i])	Limb[i].Deactivate(activator);
			
		A_UnsetShootable();
		A_ChangeLinkFlags(1);
		Super.Deactivate(activator);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		bPUSHABLE = (!other || other is "PlayerPawn" || other is "MinecraftEnemy");
		return true;
	}
	
	override bool CanResurrect(Actor other, bool passive)
	{	return false;	}
	private int Lifetime;
	override void Tick()
	{
		// Process nothing if destroyed.
		if (bDESTROYED)	return;
		
		// Destroy it if peaceful difficulty is activated, and the monster can
		// despawn on peaceful. Dead monsters will despawn on their own though.
		
		if (health > 1 &&
			(MCC_Peaceful && 
			(MCC_PeacefulBehavior <= CV_Despawn ||
			(MCC_PeacefulBehavior == CV_Minecraft && PeacefulDespawn > 0))))
		{
			Destroy();
			return;
		}
		
		Super.Tick();
		
		// Process nothing else if the actor died.
		if (IsFrozen() || health < 1)
			return;
			
		
		
		if (!bDORMANT)
		{
			if (Lifetime < 5)	Lifetime++;
			if (!DmgInfo.Used)
			{
				DmgInfo.used = true;
				DamageReact(DmgInfo.I, DmgInfo.S, DmgInfo.damage, DmgInfo.dmg, DmgInfo.mod, DmgInfo.flags, DmgInfo.angle);
			}
			//----------------------------------------------------------------------
			// Fall/Slime/Lava/Drowning damage handling.
			//----------------------------------------------------------------------
			OnGround = (Pos.Z <= FloorZ || bONMOBJ);
			
			Sector sec = CurSector;
			if (BlockingFloor)	sec = BlockingFloor;
				
			if (MCC_EnvironmentDamage && Pos.Z <= FloorZ && sec)
			{
				// if fall damage threshold is not 0 and
				// velocity is cancelled out and
				// the prior velocity descends below the threshold and
				// the sector doesn't cancel falling damage,
				// deal fall damage.
				if (MCC_FallDamage &&
					FallDmgVel != 0.0 && 
					Vel.Z >= 0.0 && PrevVel.Z <= FallDmgVel &&
					!(sec.Flags & Sector.SECF_NOFALLINGDAMAGE))
				{
					if (DoFallDamage())
					{
						SectorDamageTimer = 0;
						if (health < 1)	return;
					}
				}
				
				if (MCC_SectorDamage)
				{
					int DmgAmt = sec.DamageAmount,
						DmgInt = sec.DamageInterval;
					
					if (DmgAmt && DmgInt > 0 && 
						++SectorDamageTimer >= DmgInt)
					{
						if (DmgAmt < 0)	GiveBody(DmgAmt);
						else			DamageMobj(null, null, DmgAmt, sec.DamageType, DMG_THRUSTLESS);
						
						if (health < 1)	return;
						
						SectorDamageTimer = 0;
					}
				}
			}
			
			// Drowning
			if (MCC_Drowning && WaterLevel >= 3 && !bINVULNERABLE)
			{
				if (DrownTimer > 0)	DrownTimer--;
				else
				{
					DrownDamage++;
					DrownTimer = Second - 1;
					DamageMobj(null, null, min(DrownDamage, TELEFRAG_DAMAGE - 1), "Drowning", DMG_NO_ARMOR);
				}
			}
			else if (DrownTimer < DrownTimerStart)
			{
				DrownDamage = 0;
				DrownTimer += 3;
				DrownTimer = Min(DrownTimer, DrownTimerStart);
			}
			//----------------------------------------------------------------------
			// Play an active sound every 5-6 seconds.
			//----------------------------------------------------------------------
			if (--ActiveSoundDelay < 1)
			{
				ActiveSoundDelay += (Second * 4) + random[snd](0,Second * 2);
				if (ActiveSound != "")
					A_StartSound(ActiveSound, CHAN_VOICE, CHANF_OVERLAP);
			}
			//----------------------------------------------------------------------
			//
			//----------------------------------------------------------------------
			if (AttackDelay > 0)
				AttackDelay--;
			//----------------------------------------------------------------------
			// Handle damage timer & translation changes.
			//----------------------------------------------------------------------
			if (DamageTimer > 0 && --DamageTimer < 1)
			{
				Translation = TempTranslation;
				bBRIGHT = false;
			}
		}
		
		//----------------------------------------------------------------------
		// Update the various properties to affect the various segments.
		// Adjust the scale as needed and call the functions.
		//----------------------------------------------------------------------
		Angs = (Angle, Pitch, Roll);		
		
		if (!(vel ~== (0,0,0)))
			VelLen = vel.Length();
		else if (~(Pos ~== PrevPos))
			VelLen = level.Vec3Diff(PrevPos, Pos).Length();
		else VelLen = 0;
		
		CurStyle = GetRenderStyle();
		
		if ((LifeTime < 5) ||
			!(vel ~== (0,0,0)) ||
			PrevPos != pos ||
			PrevAngs != Angs ||
			PrevAlpha != alpha || 
			PrevStyle != CurStyle || 
			PrevTrans != Translation)
		{
			UpdateLimbs();
		}
		
		PrevTrans = Translation;
		PrevScale = Scale;
		PrevAngs = Angs;
		PrevPos = Pos;
		PrevAlpha = Alpha;
		PrevStyle = CurStyle;
		PrevVel = Vel;
	}
	private LastDamaged DmgInfo;
	private Array<Actor> Damager;
	private uint TempTranslation;
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int prevhp = health;
		int dmg = Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		
		Actor i = inflictor, s = source;
		bool painless = ((flags & DMG_NO_PAIN) || (i && i.bNOPAIN) || (!i && s && s.bNOPAIN));
		
		if (dmg > 0 && source && Damager.Find(source) >= Damager.Size())
		{
			Damager.Push(source);
		}
		
		if (MCC_Debug > 0 && s && !(s is 'PlayerPawn'))
		{
			Name src = "Null";
			Name inf = "Null";
			if (i)	inf = i.GetClassName();
			if (s)	src = s.GetClassName();
			Console.Printf("%d: %s from %s, %s", dmg, GetClassName(), src, inf);
		}
		
		if (!painless && health > 0 && dmg > 0)
		{
			if (DamageTimer < 1)
			{
				DamageTimer = 17;
				TempTranslation = Translation;
				bBRIGHT = true;
				
				SetTranslation("DamageRed");
				A_StartSound(PainSound, CHAN_VOICE, CHANF_OVERLAP);
				
				if (dmg > 0)
				{
					DmgInfo.i = inflictor;
					DmgInfo.s = source;
					DmgInfo.damage = damage;
					DmgInfo.dmg = dmg;
					DmgInfo.mod = DamageType;
					DmgInfo.flags = flags;
					DmgInfo.angle = angle;
					DmgInfo.used = false;
				}
				
				double ang = angle;
				
				if (damageType == 'Falling')
				{
					flags &= ~DMG_THRUSTLESS;
					flags |= DMG_USEANGLE;
					ang += 180;
				}
				if (!(flags & DMG_THRUSTLESS))
				{		
					if ((i && i.bNODAMAGETHRUST) || (!i && s && s.bNODAMAGETHRUST))
					{
						if (!(flags & DMG_USEANGLE))
							flags |= DMG_THRUSTLESS;
					}
				}
				
				if (!(flags & (DMG_THRUSTLESS|DMG_EXPLOSION)))
				{	
					Vector2 v = Vel.XY;
					if (Vel.Z <= 0)
						Vel.Z += 7.0;
					
					if ((flags & DMG_USEANGLE))
						ang = angle;
					else if (s)	ang = AngleTo(s);
					else if (i)	ang = AngleTo(i);
					Thrust(-1, ang);
				//	VelFromAngle(-2, ang);
				//	Vel.XY += v;
				}
			}
		}
		return dmg;
	}
	
	//private MC_LineContainer CurLines;
	//bool FromDmgSector;
	/*
	override bool CanCrossLine(Line crossing, int side)
	{
		// Already in a sector that's burning the monster, and may need to
		// cross over some in order to reach ground without it, so allow it.
		if (CurSector.DamageAmount > 0)
			return true;
		
		Line l = crossing;
		
		double ang = VectorAngle(l.delta.x, l.delta.y) + 90;
		double delta = AbsAngle(ang, angle);
		
		if (l.frontsector.DamageAmount < 1 && delta >= 90)
			return true;
		if (l.backsector.DamageAmount < 1 && delta <= 90)
			return true;
		
		// Crossing over the front side, so check the back sector.
		if (side == Line.Front)
			return (l.backsector.DamageAmount < 1);
		
		// Vice versa.
		return (l.frontsector.DamageAmount < 1);
	}
	*/
	private Vector3 DeathPos;
	override void Die(Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath)
	{
		
		DeathPos = pos;
		
		// This is primarily to stop D(E)4D resources from dropping if never killed
		// by a player. Actors with NOINTERACTION never drop resources on death.
		// They drop by WorldThingDied so they can drop from any monster.
		// This is needed because otherwise, they would rain upgrades.
		
		// This is a temporary solution and a bit of a hack. Eventually, I'll
		// introduce something on DE4D's side and remove it later.
		
		if (!(source is 'PlayerPawn') && Damager.Size() < 1)
		{
			bNOINTERACTION = true;
			A_ChangeLinkFlags(1);
		}
		
		A_NoBlocking(false);
		if (MCC_DropItems)
			DropItems(source, inflictor, MeansOfDeath);
		
		Super.Die(source, inflictor, dmgflags, MeansOfDeath);
		
		if (Damager.Size() > 0)
		{
			bNOINTERACTION = true;
			A_ChangeLinkFlags(1);
		}
		// Boing!
		if (MeansOfDeath == 'Falling')
		{
			Vel.Z = abs(PrevVel.Z);
		}
		VelLen = Vel.Length();
		Gib(VelLen);
		SetOrigin(DeathPos, false);
		A_Stop();
		A_Scream();
	}
	
	override void OnDestroy()
	{
		DestroyLimbs();
		RemoveGoal();
		Super.OnDestroy();
	}
		
	States
	{
	Spawn:
		TNT1 A 35;
	Idle:
		---- A 0 A_Jump(256, random(1, 4));
		---- AAAAAAAAAA 17 Look();
	IdleMove:
		---- A 0 
		{
			LookTimer = 0;
			return A_Jump(256, random(1, 35*2));
		}
		---- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		---- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		---- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		---- AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 LookWander();
		Goto Idle;
	Death:
		TNT1 A 35;
		Stop;
	}
}

Class MCGoal : MinecraftEntity
{
	Default
	{
		+NOINTERACTION
		+NOBLOCKMAP
		+NOTONAUTOMAP
		+DONTBLAST
	}
	override void OnDestroy()
	{
		A_SpawnItemEx('MCExplosion', flags: SXF_NOCHECKPOSITION);
		Super.OnDestroy();
	}
	
	States
	{
	Spawn:
		TNT1 A 8 A_SpawnItemEx('MCExplosionSmoke', frandom(0,3), 0, frandom(1,3), frandom(0,2), 0, frandom(0, 2), random(0,359), SXF_NOCHECKPOSITION);
		Wait;
	}
}

//------------------------------------------------------------------------------
// Subtypes
//------------------------------------------------------------------------------

Class MCUndead : MinecraftEnemy
{
	Default
	{
		MinecraftEnemy.MobType M_Undead;
		DamageFactor "Poison", 0.0;
	}
}

Class MCAnthropod : MinecraftEnemy
{
	Default
	{
		MinecraftEnemy.MobType M_Anthropod;
		DamageFactor "Poison", 0.0;
	}
}

Class MCBoss : MinecraftEnemy
{
	Default
	{
		+BOSS
		MinecraftEnemy.MobType M_Normal;
		DamageFactor "Poison", 0.0;
		DamageFactor "Wither", 0.0;
		DamageFactor "Fire", 0.0;
		DamageFactor "Drowning", 0.0;
		DamageFactor "Falling", 0.0;
	}
}

Class MCMobLineTracer : LineTracer
{
	
}