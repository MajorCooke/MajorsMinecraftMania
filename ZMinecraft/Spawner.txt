extend class MinecraftHandler
{
	// The primary spawn list.
	private void CreateSpawnList()
	{
		SpawnList = MCSpawnList.Create();
		SpawnList.Add('MCZombie',			28);
		SpawnList.Add('MCZombieBaby',		02);
		SpawnList.Add('MCSkeleton',			30);
		SpawnList.Add('MCCreeper',			10);
	}
	
	private AArray SpawnQueue;
	private AArray SpawnQueuePriority;
	private CAArray ClsQueue;
	private CAArray ClsQueuePriority;
	private MinecraftEnemy MoToSpawn;
	private int MaxMobs;
	
	private void InitQueues()
	{
		SpawnQueue = AArray.Create();
		SpawnQueuePriority = AArray.Create();
		ClsQueue = CAArray.Create();
		ClsQueuePriority = CAArray.Create();
	}
	
	// Checks all queued classes for peaceful despawning. If they do, removes
	// them from the queue.
	private void CheckClassQueues()
	{
		CAArray rays[2];
		rays[0] = ClsQueue;
		rays[1] = ClsQueuePriority;
		
		for (int i = 0; i < rays.Size(); i++)
		{
			Array<Class<Actor> > temp; temp.Clear();
			// CAArray has a Size() function to get the Classes[index].Size().
			for (int j = 0; j < rays[i].Size(); j++)
			{
				Class<Actor> c1 = rays[i].Classes[j];
				if (c1)
				{
					let check = (Class<MinecraftEnemy>)(c1);
					if (check)	
					{
						let defs = GetDefaultByType(check);
						if (!defs.PeacefulDespawn)
							temp.Push(c1);
					}
				}
			}
			rays[i].Classes.Move(temp);
		}
	}
	
	//==========================================================================
	// Performs the countdown to attempt spawning monsters.
	// 
	// If peaceful mode is enabled or monster spawning disabled, forces the
	// timer to 1 second and holds it there until monsters are allowed to spawn.
	//==========================================================================
	private bool WasPeaceful;
	private void HandleMapSpawns()
	{
		if (!MCC_Spawning ||(MCC_Peaceful && MCC_PeacefulBehavior <= CV_Stay))
		{
			Timer[S_Spawn] = 35;
			
			// Everything Minecraft related must despawn.
			// Monsters auto-destroy themselves when set to force despawn, so
			// wipe it all out.
			if (MCC_Peaceful && !WasPeaceful)
			{
				if (MCC_PeacefulBehavior <= CV_Despawn)
				{
					SpawnQueue.Clear();
					SpawnQueuePriority.Clear();
					ClsQueue.Clear();
					ClsQueuePriority.Clear();
				}
				else if (MCC_PeacefulBehavior == CV_Minecraft)
				{
					CheckClassQueues();
				}
			}
		}
		else if (--Timer[S_Spawn] < 1)
		{
			if (Timer[S_Spawn] == 0)
			{
				for (int i = 0; i < MAXPLAYERS; i++)
				{
					if (!playeringame[i] || !players[i].mo)	continue;
					let plr = players[i].mo;
					if (plr && !plr.FindInventory('MCPlayerProtection'))
						plr.A_GiveInventory('MCPlayerProtection',1);
				}
			}
			TriggerMapSpawns();
		}
		WasPeaceful = MCC_Peaceful;
	}
	
	//==========================================================================
	// Handles the clock for spawning monsters and queued monsters.
	//==========================================================================
	private void TriggerMapSpawns()
	{
		int ret = -1;
		
		int reset = Max(35,
			Minute * MCC_SpawnDelayMinute + 
			Second * MCC_SpawnDelaySecond + 
			Second * random[rng](0,MCC_SpawnDelayRandom));
		
		MaxMobs = int(round(MCC_Spawns * MCC_SpawnMul));
		
		PrepareSpawnNormal(SpawnQueuePriority, ClsQueuePriority);
			
		if (MobCount < MaxMobs)
			PrepareSpawnNormal(SpawnQueue, ClsQueue);
		else ret = reset;
		
		Timer[S_Spawn] = ret;
	}
	
	
	
	//==========================================================================
	// Attempts a normal map spawn via timer, and prepares it for creation.
	// Only attempts to create 10 monsters at a time in order to keep a lid on
	// performance issues.
	//==========================================================================
	
	const MaxQueue = 10;
	private bool PrepareSpawnNormal(out AArray Cue, out CAArray ClsCue)
	{
		if (!SpawnList)	CreateSpawnList();
		
		if (!Cue)		Cue = AArray.Create();
		if (!ClsCue)	ClsCue = CAArray.Create();
		
		// Go through the specified class queue and try to spawn as many of the
		// monsters as possible, settinng them all as dormant.
		if (Cue.Size() < 1)
		{
			bool Finished = true;
			for (int i = 0; i < ClsCue.Size(); i++)
			{
				if (!ClsCue.Classes[i])	continue;
				
				let mon = MinecraftEnemy(Actor.Spawn(ClsCue.Classes[i], (0,0,0), ALLOW_REPLACE));
				if (mon)
				{
					mon.bNODROPOFF = true;
					mon.Deactivate(null);
					Cue.Push(mon);
					
					// Only spawn so many.
					if (Cue.Size() >= MaxQueue && Cue.Clean() >= MaxQueue)
					{
						Finished = false;
						break;
					}
				}
			}
			if (Finished)
				ClsCue.Clear();
		}
		
		//----------------------------------------------------------------------
		// Now try to position them one at a time for activating.
		if (!MoToSpawn)	
		{
			for (int i = 0; i < Cue.Size(); i++)
			{
				if (!Cue.Actors[i])	continue;
			
				MoToSpawn = MinecraftEnemy(Cue.Actors[i]);
				if (MoToSpawn)	
				{
					Cue.Actors[i] = MoToSpawn;
					break;
				}
				
			}
			
			// The queue is empty, so generate a random mob.
			if (!MoToSpawn)
			{
				Class<Actor> mo = SpawnList.PickRandom();
				if (!mo)	return false;
				
				MoToSpawn = MinecraftEnemy(Actor.Spawn(mo, (0,0,0), ALLOW_REPLACE));
				if (MoToSpawn)
				{
					MoToSpawn.bNODROPOFF = true;
					MoToSpawn.Deactivate(null);
				}
				else return false;
			}
		}
			
		return AttemptMonsterPlacement();
	}
	
	bool AttemptMonsterPlacement()
	{
		if (!MoToSpawn)	return false;
	
		// Not exactly player aware but honestly, GZDoom isn't in a state of
		// multiplayer friendly at the moment so just get the closest player
		// and spawn around them.
		MoToSpawn.Deactivate(null);
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (!playeringame[i] || !players[i].mo)	continue;
			Actor plr = players[i].mo;
			if (!plr)	continue;
			
			
			
			double inc = 30;
			double div = 360 / inc;
			double ang = random[rng](0,12) * inc;
			
			int j = random[rng](0,inc);
			
			for (int k = 0; k < inc; k++)
			{
				j = (j + 1) % inc;
				ang = random(0, inc) * j;
				double dist = random[rng](32, 128) * 32;
				Vector3 next; next.XY = plr.Vec2Angle(dist, ang);
				next.Z = MoToSpawn.GetZAt(next.X, next.Y, ang, GZF_ABSOLUTEPOS|GZF_ABSOLUTEANG|GZF_NO3DFLOOR);
				if (!level.IsPointInLevel(next) || level.Vec3Diff(next, plr.pos).Length() > 4096)
					continue;
					
				Sector s = Level.PointInSector(next.XY);
				
				if (MCC_EnvironmentDamage && MCC_SectorDamage && s.DamageAmount > 0 &&
					MoToSpawn.ApplyDamageFactor(s.DamageType, s.DamageAmount) > 0)
					continue;
					
				MoToSpawn.SetOrigin(next, false);
				MoToSpawn.SetZ(MoToSpawn.FloorZ);
				
				
				
				if (MoToSpawn.TryMove(MoToSpawn.pos.XY, false))
				{
					MoToSpawn.bNODROPOFF = MoToSpawn.Default.bNODROPOFF;
					MoToSpawn.Angle = random(0,359);
					MoToSpawn.Activate(null);
					MoToSpawn.AlignMoveDir();
					MoToSpawn = null;
					return true;
				}
			}
		}
		return false;
	}
}

//==============================================================================
// Spawn Lists
//
// MCSpawn contains the classname, group it belongs to, and weight of the spawn.
// The weight behaves exactly like RandomSpawner's.
//==============================================================================
Class MCSpawn play
{
	Class<Actor> ClassName;
	Name Group;
	Int Weight;
}

Class MCSpawnList play
{
	private Array<MCSpawn> Classes;
	
	static MCSpawnList Create()
	{
		let s = new('MCSpawnList');
		s.Clear();
		return s;
	}
	
	//--------------------------------------------------------------------------
	// Adds a class. Must be valid and weight > 0 or it won't add.
	// If the class is already existing, update it instead of wasting memory.
	// Also, only changes the group if not '' (blank). Use 'None' to clear.
	void Add(Class<Actor> cls, int w, Name g = '')
	{
		if (!cls)	return;
		
		int size = Classes.Size();
		
		for (int i = 0; i < Classes.Size(); i++)
		{
			if (cls == Classes[i].ClassName)
			{
				Classes[i].Weight = w;
				if (g == 'None')	Classes[i].Group = '';
				else if (g != '')	Classes[i].Group = g;
				
				return;
			}
		}
		
		let sp = new('MCSpawn');
		sp.ClassName = cls;
		sp.Weight = w;
		sp.Group = (g == 'None') ? '' : g;
		
		Classes.Push(sp);
	}
	
	void Clear()	{	Classes.Clear();	}
	
	//--------------------------------------------------------------------------
	// Picks a random monster based on the group it belongs to.
	// If no group is specified, it'll choose any.
	//
	// Arguments
	//	*group 
	//		Filters the selection by the group given (whitelist)
	//	*exclude
	//		If true, blacklists the group instead of whitelist.
	Class<Actor> PickRandom(Name group = '', bool exclude = false) const
	{
		if (Classes.Size() < 1)
			return null;
	
		bool any = (group == '' || group == 'None');
		
		Array<Class<Actor> > Queue;	Queue.Clear();
		Array<Int> Chances;			Chances.Clear();
		int Weight = 0;
		int Size = Classes.Size();
		
		// Get all applicable entities.
		for (int i = 0; i < Classes.Size(); i++)
		{
			let c = Classes[i];
			if (!c || !c.ClassName || c.Weight < 1)
				continue;
			
			if (!any)
				if ((exclude && group == c.Group) || (!exclude && group != c.Group))
					continue;
			
			Queue.Push(c.Classname);
			Chances.Push(c.Weight);
			Weight += c.Weight;
		}
		
		Size = Queue.Size();
		if (Size > 1)
		{
			int n = random[rng](0, Weight - 1);
			
			for (int i = 0; i <= Size; i++)
			{
				if (i >= Size)
					i = 0;
					
				n -= Chances[i];
				
				if (n < 0)	return Queue[i];
			}
		}
		else if (Size == 1)
			return Queue[0];
		
		return null;
	}
}

/*
Class MCSpawnGroup play
{
	Name GroupName;
	Array<MCSpawn> Group;
	
	static MCSpawnGroup Create(Name g)
	{
		let gr = new('MCSpawnGroup');
		gr.GroupName = g;
		gr.Group.Clear();
		return gr;
	}
}
*/